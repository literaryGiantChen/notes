redis官网命令：https://www.redis.net.cn/order/3550.html

http://download.redis.io/releases/redis-5.0.4.tar.gz

## 为什么Redis这么快？

**Redis**采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的**QPS（每秒内查询次数）**。

首先，采用了多路I/O复用模型，非阻塞IO

然后，数据结构简单，操作节省时间

最后，运行在内存中，自然速度



## 应用场景

https://blog.csdn.net/qq_39938758/article/details/105577370

缓存、数据共享分布式、分布式锁、全局ID、计数器、限流、位统计、购物车、用户消息时间线timeline、消息队列、抽奖、点赞，签到，打卡、商品签到、商品筛选、用户关注，推荐模型、排行榜

https://blog.csdn.net/u011277123/article/details/78692603?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link

一、为什么使用

1. 解决应用服务器的cpu和内存压力
2. 减少io的读操作，减轻io的压力
3. 关系型数据库的扩展性不强，难以改变表结构

二、优点：

1. nosql数据库没有关联关系，数据结构简单，拓展表比较容易
2. nosql读取速度快，对较大数据处理快

**三、适用场景：**

1. **数据高并发的读写**
2. **海量数据的读写**
3. **对扩展性要求高的数据**

四、不适场景：

1. 需要事务支持（非关系型数据库）
2. 基于sql结构化查询储存，关系复杂



## 缓存穿透

用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

### 解决方案

1、**布隆过滤器**

那这个布隆过滤器是如何解决redis中的缓存穿透呢？很简单首先也是对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询。

原理：也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

2、**缓存空对象**

当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源

但是这种方法会存在两个问题：

1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的2、键；即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。

3、**用户鉴权校验**

参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。

## 缓存击穿

是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

### 解决方案

设置热点数据永远不过期

```java
public static String getData(String Key) throws InterruptedException {
        // 从redis查询数据
        String result = getDataByKV(Key);
        // 参数校验
        if (StringUtils.isBlank(result)) {
            // 获取锁
            if (reenLock.tryLock()) {
                // 去数据库查询
                result = getDataByDB(Key);
                // 校验
                if (StringUtils.isNotBlank(result)) {
                    // 搞进缓存
                    setDataToKV(Key, result);
                }
                // !!!释放锁 正常会在finally里面释放
                reenLock.unLock();
            } else {
                // 睡一会再拿
                Thread.sleep(100L);
                result = getData(Key);
            }
        }
        return result;
    }
// 这里面的锁都是单机玩玩，分布式锁还是得靠lua脚本这样的
```

## 缓存雪崩

缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。

**举个简单的例子**：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。

### **解决方案**

**（1）redis高可用**

这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。

**（2）限流降级**

这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

**（3）数据预热**

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。



## Redis数据结构

字符串String、字典Hash、列表List、集合Set、有序集合SortedSet、HyperLogLog、Geo、Pub/Sub



## 分布式锁

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放

**这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**

我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！



## Redis是怎么持久化的？服务主从数据怎么交互的？

RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。



## 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。



## 如何解决redis缓存和mysql数据一致性问题？

https://zhuanlan.zhihu.com/p/128682386

”延时双删“ 和 ”闪电缓存“



## redis相比memcached有哪些优势？

- memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
- redis的速度比memcached快很多
- redis可以持久化其数据

## Memcache与Redis的区别都有哪些？

- 存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。
- 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。