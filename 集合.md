## 简述集合

### 概念

Java中的集合就是一种容器，可以容纳不同种类的数据，这些容纳是建立在未知的基础上。

#### 优点

1.可以动态保存任意多个对象，使用比较方便。

2.提供一系列方便的操作对象的方法：add、remove、set、get等

3.使用集合添加，删除新元素的示意代码简洁。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614101022172.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXN0cmVo,size_16,color_FFFFFF,t_70#pic_center)



单列父类是collection,   双列父类是map

### 单列

collection主要：list可重复元素 和 set不可重复元素

List集合特点：有序，有下标，可重复		List接口下主要实现类：ArrayList、Vector、LinkedList

ArrayList、Vector 底层数据结构是数组，LinkedList 底层数据结构是双向链表

Set集合特点：无序，无下标，不可重复	Set接口下主要实现类：HashSet、TreeSet

HashMap,HashMap底层数据结构是Hash表，TreeMap底层数据结构是二叉树

### 双列

1)key和value存储的都是对象的内存地址，也就是引用

2)Map中所有的key都是无序不重复的

3)Map集合的key和Set集合存储元素特点相同，因为Set和存储元素的时候就是把元素存储到了Map集合的key中

Map集合下主要有三个实现类，HashMap，Hashtable ，TreeMap



## ArrayList的特点

　　1.ArrayList的底层数据结构是动态数组，所以查找遍历快，增删慢。

　　2.ArrayList可随着元素的增长而自动扩容，正常扩容的话，每次扩容到原来的1.5倍。

　　3.ArrayList的线程是不安全的。



## ArrayList 和 Vector 的区别

同步性
		这两个类实现了List接口，都是有序集合，即存储元素的位置索引也是有序，数据允许重复的，相当于一种动态数组。
		vector是线程安全的，也就说方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。
数据增长
		Vector 增长原来的一倍，ArrayList 增加原来的 1.5 倍。

记住Vector 与 Hashtable 是旧的，是 java 一诞生就提供了的，它们是线程安全的，
	ArrayList 与 HashMap 是 java2 时才提供的，它们是线程不安全的。



## LinkedList 和 ArrayList 的区别

存储：动态数组		双向循环链表

修改元素：较慢		较快

可用：列表				列表和队列

存储、访问性能较好o(1)	修改元素 性能较好o(n)

## List 、Set、 Map有什么区别和联系

​	list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以
​	list和set的用途非常广泛 list可以完全代替数组来使用
​	map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用
​	map不像上边两种集合那个用的广泛 不过在servlet 和jsp中 map可是绝对的重中之重 页面之间传值全靠map



## 集合中为什么要设计这个迭代器

迭代器：->将集合看做成一个公共汽车时，其中的乘客就是一个个数据，如果我想遍历出每个数据，或者说是查找某一个乘客的话，让售票员去找（迭代器iterator）
​	这就会不会暴露==内部数据和结构==，提高==安全性==
​	使用：
​		ArrayList arrayList=new ArrayList();
​		arrayList.add("1");
​		arrayList.add("c");
​		arrayList.add("33");
​		arrayList.add("cc");

```java
	ListIterator listIterator = arrayList.listIterator();
	while (listIterator.hasNext()){
		//表示的迭代器直接可以将数据的集合，通过方法-区创建一个迭代器对象，只能是单独的一个；
		Object object = listIterator.next();
		System.out.println(object);
	}

优点: 
   1.可以不了解集合内部的数据结构,就可以直接遍历
   2.不暴露内部的数据,可以直接外部遍历;
   3.适用性强,基本上的集合都能使用迭代器;

迭代器本质是一种设计模式，为了解决为不同的集合类提供统一的遍历操作接口
```


## concurrentMap和hashMap的区别

https://yuanrengu.com/2020/ba184259.html

concurrentMap线程安全 速度慢 分段锁 不是整体锁

hashMap线程不安全 速度快

Hashtable 线程安全,速度最慢 因为是整体的锁，基本被淘汰了

concurrentMap 适合用于并发编程，其实就是在要求线程安全的时候用它，因为hashmap虽然效率高但是线程不安全,hashtable线程安全缺效率太低



## hashMap理解

1，hashmap是我们几乎每天用到的集合类,它以键值对的形式存在。
2,   在jdk1.7中：底层是数组加链表，1.8中采用的是数组加链表加红黑树，红黑树的引入是为了提高查询效率
3，1.7中hash碰撞采用头插法，头插法会形成循环链表（？），1.8尾插法
4，hash算法1.8进行了简化，up主记不清了，
5，最好传入一个二的次幂的初始化容量， put时，会初始化数组，容量为大于等于初始化容量的最近的二次幂，	  比如初始化容量为6，他初始化就是8。
6，key的hash值 与 上容量-1，计算出所在位置
7，扩容的问题：加载因子0.75，达到 容量 * 0.75后就会扩容，两倍扩容  
8，树化，数组容量达到64,链表长度大于等于8，后才会进行树化，链表长度小于6就会解除树化

HashMap默认采用数组+单链表方式存储元素，当元素出现哈希冲突时，会存储到该位置的单链表中。与JDK1.7相比，单链表不会一直增加元素，当元素个数超过8个时，会尝试将单链表转化为红黑树存储。但是在转化前，会再判断一次当前数组的长度，只有数组长度大于64才处理。否则，进行扩容操作。

JDK1.8中首先判断此时是否为树结构，如果是，插入新元素为树中的一个结点，否则遍历链表道末尾，将新元素未插入到链表末尾，然后判断链表长度是否超过转化数的临界值。

Hash本质是个散列算法，用hash算出锁引位置，利用数组，连续内存特性，可以快速定位key所在区域，而不需要遍历数组，对于散列值相同的会出现碰撞，hashmap采用的是拉链法处理，使用equals遍历链表最终定位，考虑到碰撞严重的情况，链表过长，影响性能，hashmap采用了tree,为了查找和插入之间做平衡选择了红黑树做为查找树，根据统计8位链表的性能和红黑树在平均概率下差不多，所以变为红黑树的阈值为8

### 1.为什么JDK1.8采用红黑树存储Hash冲突的元素？

红黑树本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。能够加快检索速率。

### 2.为什么在长度小于8时使用链表，不一直使用红黑树？

桶中元素的插入只会在hash冲突时发生，而hash冲突发生的概率较小，一直维护一个红黑树比链表耗费资源更多，在桶中元素量较小时没有这个必要。

### 3.为什么要使用红黑树而不使用AVL树？

红黑树与AVLl树，在检索的时候效率差不多，都是通过平衡来二分查找。但红黑树不像avl树一样追求绝对的平衡，红黑树允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树。

### 4.为什么数组容量必须是2次幂？

索引计算公式为i = (n - 1) & hash，如果n为2次幂，那么n-1的低位就全是1，哈希值进行与操作时可以保证低位的值不变，从而保证分布均匀，效果等同于hash%n，但是位运算比取余运算要高效的多。

### 5.为什么单链表转为红黑树要求桶内的元素个数大于8？

当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，而一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。

同理，少于6就从红黑树转回单链表是为了节省维护一个树的资源消耗，而选择6作为临界值，是因理想情况下一个bin中元素个数达到6的概率是0.00001316，达到7的概率为0.00000094，二者跨度较大，可以减小树和链表之间频繁转化的可能性。

### hashmap加载因子为什么是0.75

https://www.cnblogs.com/aspirant/p/11470928.html

加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；

**加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数**。

所以：**提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，**

